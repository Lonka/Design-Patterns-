---------------------------------------------------------------------------
Folder:DesignPatternInterduction
即策略模式(Strategy Pattern)
[定義了演算法家族（即Implement的class），個別封裝起來，讓它們之間可以互相替
換，此模式讓演算法的變動，不會影響到使用演算法的程式。]
==================================說明=====================================
將behavior寫成各各分開的類別
並Implement同一個interface
在要用到的主類別中開個該interface的屬性
這樣在實體化該主類別時便可以在建構式中動態加入behavior類別。
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:ObserverPattern
即觀察者模式(Observer Pattern)
[定義了物件之間的一對多關系，如此一來，當一個物件改變狀態，其他相依者都會收
到通知並自動被更新。]
==================================說明=====================================
在主subject的類別中implement isubject
其中包含register and remove iobserver和notify Observer。
並讓所有observer的類別implement iobserver,其中包含update
這樣便可在實體化subject時便register observer
在適當的時後便可呼叫subject的notify
同步更新所有observer。
===========================================================================
-----------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:DecoratorPattern
裝飾者模式(Decorator Pattern)
動態地將責任加諸於物件上。若要擴充功能，裝飾者提供了比繼承更有彈性的選擇。
==================================說明=====================================
很像遞迴的感覺
先開一個大家都要繼承(Inherit)的主體抽象類別(abstract class)
然後被裝飾者inherit它
裝飾者inherit它(
  裝飾者如有別的別的方法必需implement時
  可以先開一個裝飾者的abstract class inherit 主體的abstract class 
  再讓所有裝飾者inherit裝飾者的abstract class
  這樣所有裝飾者也等於繼承了主體且可以implement裝飾者的方法
  )
之後每個裝飾者都必需記著上一層的裝飾結果
以便層層往回找
且每個裝飾著override主體abstract class的方法
這樣在最外層呼叫主體的方法時便會層層找進去再將結果層層傳出來。
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:FactoryPattern
工廠模式(Factory Pattern)
定義了一個建立物件的介面，但由次類別決定要實體化的類別為何者。工廠方法讓類
別把實體化的動作，交由次類別進行。
==================================說明=====================================
其實它主要是為了去除程式中重覆無義的Switch or If
所以會把這此判斷式移到一個類別做
如果只是一個Concrete Creator那只需要一個類別便可搞定
故為「簡單工廠模式」
但有多個Concrete Creator時便需要建立一個抽象類別讓Concrete CreatorInherit它
這樣便可由次類別決定要實體化的類別。(FactoryPattern->OrderPizza.aspx.cs有說明)
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:FactoryPattern->FactoryInterface
抽象工廠模式(Abstract Factory Pattern)
提供了一個介面，建立相關或相依物件之家族，而不需明確指定具象類別。
==================================說明=====================================
我一直覺得這個就是把策略模式(Strategy Pattern)強化
在Strategy Pattern中便只做到Dough or Sauce folder中的做法
而Abstract Factory Pattern中便是再用一個介面
包起來Dough and Sauce(IPizzaIngredientFactory)
再建立兩個實作該介面的工廠
這樣就可以直接使用該工廠傳出相對應的類別。
===========================================================================
(FactoryPattern->OrderPizza.aspx.cs
 FactoryPattern->ConcreteProduct->GreekPizzaNY有說明)
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:SingletonPattern
獨體模式(Singleton Pattern)
確保一個類別只有一個實體，並提供全域點存取此實體。
==================================說明=====================================
直接看SingletonPattern->SingletonPatternPate1.aspx.cs 跟 
SingletonPattern->Singleton.cs中的寫法比較快
比較有趣的是原來可以讓class的建構式是private
這樣就只能由自己實體化自己
再建立一個static方法實體化該類別
這樣就可以讓該類別呼叫static方法實體化方法
並確保不會有多個實體。
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:CommandPattern
命令模式(Command Pattern)
將請求封裝成物件，這可以讓你使用不同的請求、佇列、或者日誌，來參數化其他
物件。命令模式也可以支復原操作。
==================================說明=====================================
命令模式就是為了讓
「請求物件(like:Light)」和
「執行請求(Execute)」之間鬆綁
將每個動作拆成一個個的命令(like:LightOnCommand)
並Implment ICommand 中的Execute
並讓調用者(invoker:SimpleRemoteControl)去記錄每個ICommand
在調用執行方法時
將每個記錄的ICommand執行Execute這樣接收者(Receiver)便不需要知道
調用了那些命令
只需要執行已存命令。
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:AdapterPattern
轉接器模式(Adapter Pattern)
將一個類別的介面，轉換成另一個介面以供客戶使用。轉接器讓原本介面不相容的類別
可以合作無間。
==================================說明=====================================
轉接器模式
簡單來說透過轉接器可以讓使用者感覺不出兩個類別的差異
在folder的例子中IDuck跟ITurkey是完全不相同的類別(介面)
但轉接器(TurkeyAdapter)可以讓使用者建置Turkey但使用的是Duck的方法
做法也很簡單
讓轉接器(TurkeyAdapter)Implement IDuck的方法
並在初使建構式中就載入ITurkey的類別且記錄著
這樣就可以在IDuck的方法中直接調用ITurkey的方法
而使用者也只感覺到是使用IDuck的方法。
===========================================================================
---------------------------------------------------------------------------


---------------------------------------------------------------------------
Folder:FacadePattern
表象模式(Facade Pattern)
提供了一個統一的介面，用來存取次系統中的一群介面。表象定義了一個較高層次的介
面，讓次系統更容易使用。
==================================說明=====================================
表象模式真的還蠻簡單的
其實就是做一件事如果需要動用到很多類別時並調用很多該類別的方法時
最好建立一個表象
即統一的介面
讓該介面提供一個方法並在該方法
中調動原本應該做的事
這樣就可以該使用者只需要跟表象溝通並調用表象中的一個方法即可。
===========================================================================
---------------------------------------------------------------------------


---------------------------------------------------------------------------
Folder:TemplatePattern
樣板模式(Template Pattern)
將一個演算法的骨架定義在一個方法中，而演算法本身會用到的一些方法，則是定義在
次類別中。樣板方法讓次類別在不改變演算法架構的情況下，重新定義演算法中的某些
步驟。
==================================說明=====================================
樣板模式也是很簡單也實用的模式
就是在super abstract class 中定義一個algorithm(演算法)
而algorithm中的一些需要由次class決定的method定義成abstract
讓次class去override
這樣就可以讓同一個algorithm因不同的concrete class而實作出不同的結果
當然！如果要由concrete class改變algorithm可以在algorithm中加入hook
並在super abstract class中加入一個virturl hook
讓concrete class可以決定是否要override hook。
===========================================================================
---------------------------------------------------------------------------


---------------------------------------------------------------------------
Folder:IteratorPattern
反覆器模式(Iterrator Pattern)
讓我們能夠取得一個聚集內的每一個元素，而不需要此聚集將其實踐方式暴露出來。
==================================說明=====================================
實現每一種集合的反覆器
讓使用都可以直接對反覆器去取集合的值而不需要知道是對什麼集合取值。
用法便是針對要回傳集合的class去實現每一個的反覆器
並實作反覆器的介面(IteratorPattern->Iterator->IteratorImpl->以下的兩個反覆器class)
讓介面包含hasNext和Next方法
    (當然如果要往前找就再新增往前的方法) 
再讓每一個要回傳集合的類別去實作方法Return Iterator Interface
這樣在使用時便可以呼叫每一個集合類別
並取得該類別的反覆器
這樣便可針對反覆器的hasNext跟Next去取值而不需要知道集合的類型。
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:CompositePattern
合成模式(Composite Pattern)
允許你將物件合成樹狀的結構，用來呈現「部份/整體」的階層關系。利用合成，客戶程式碼能
夠一視同仁地對待個別的物件以及物件合成的結果。
==================================說明=====================================
合成模式即開發一個abstract class
該類別包含leaf node和composite node所需要的方法
然後讓兩種node都去inherit並implement它

然後讓composite node去implement add、remove等方法
並用一個list去記錄add的class

讓leaf去implement print等方法

最後用iterator就可以讓結果印出來。
合成反覆器，這個比較難懂，直接看程式碼會比較好懂CompositePattern->ComponentTest.aspx.cs
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:StatusPattern
狀態模式(State Pattern)
允許物件隨著內在的狀態改變而改變行為，就好像物件的類別改變了一樣。
==================================說明=====================================
狀態模式跟策略模式真的很像
狀態是把狀態行為封裝起來
在執行時會改變它
簡單來說會在context中記著目前state(GumballMachine.cs)
然後再執行這些狀態方法時(state.function)
會去該狀態行為(state behavior)中的方法執行
並改變目前狀態(gumballMachine.SetState)
這樣在下次執行別的方法時就會執行該狀態的方法。
===========================================================================
---------------------------------------------------------------------------

---------------------------------------------------------------------------
Folder:ProxyPattern
代理人模式(State Pattern)
讓某個物件具有一個替身，藉以控制外界對此物件的接觸。
==================================說明=====================================
(1)遠端代理人
   遠端代理人最好懂的說法
   便是Web Service
   透過Web Service可以讓客戶端以為是直接跟server溝通
   底層程式來看的話即用.NET的Remoting模組
   簡單來說我有一台飲料機(DrinkMachine.cs)
   該飲料機有提供遠端讀取資料的服務(testDrinkMachine.aspx)
   利用的是飲料機報表監控系統(DrinkMachineRemote.cs)
   該報表監控系統為了讓與老闆(RemoteClient->Program.cs)分離
   故實作一個遠端服務的介面(RemoteService->IDrinkMachineRemote.cs)
   讓老闆只需要透過Remoting取得報表監控介面
   便可以直接調出飲料機的報表資料
   註：Demo流程為先執行(testDrinkMachine.aspx)並可以實際去買飲料
       之後再去執行老闆監控軟體(RemoteClient->Program.cs)
	   就可以即時看到飲料機現狀
===========================================================================
---------------------------------------------------------------------------